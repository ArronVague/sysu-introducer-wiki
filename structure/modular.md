# 模块化

虽然在之前的系统设计上，我们称系统中的每一个功能组件都是一个模块，
但实际上在具体的代码实现，每个模块的内部实现不同，导致其具体实现上有一定的差异，
使得我们需要为每个类都涉及一套代码实现，并且还需要手动地加载和连接各个模块。

因此，为了简化这部分的代码开发工作量，让系统本身自动化地完成模块加载和连接，
我们提出了模块化的思想。

> 注意：本系统在代码实现层面不再刻意区分 `interface` 和 `module`，
> 而是在具体的功能性质上有所差异。
> 比如 `interface` 主要负责对外交互，`module` 主要负责内部实现。

## 概念

<!-- 这里模块化思想其实与 Linux 系统中的文件系统如出一辙，
在 Linux 系统中，所有的硬件设备、文件内容和文件夹都属于文件，
共用一套统一的 IO 控制接口。 -->

<!-- 在我们这套系统中也是如此，任何一个具体模块都继承与一个统一的模块接口，
它们共用一套统一的启动、运行和管理接口。
此外，模块之间也能互相嵌套（不允许发生循环依赖），父模块会自动加载子模块。 -->

在本系统中，我们使用 `BasicModule` 来统一所有的模块，
每个具体的模块都拥有其对应的实现。
此后，我们通过 `ModuleManager` 保存每个模块与其基本信息，并进行统一管理。

![img](./img/modular.svg)

## 属性

`ModuleInfo` 对象用于存储每个模块的基本属性，
`module.json` 文件会持久化地存储这些属性信息。

| 名称         | 字段    | 默认值      | 可见性 | 备注                                    |
| ------------ | ------- | ----------- | ------ | --------------------------------------- |
| 名称         | name    | 必须        | yes    |                                         |
| 别名         | alias   | 必须        | yes    | 模块对应的中文名                        |
| 子模块列表   | modules | `[]`        | yes    | 存储包含的子模块                        |
| 实现类型     | kind    | `basic`     | yes    | `basic` 指只有一种实现, `null` 指为实现 |
| 实现类型列表 | kinds   | `[]`        | yes    | 存储目前已经支持的试下类型              |
| 状态         | status  | `NotLoaded` | yes    |                                         |
| 路径         | path    | `.`         | no     | 模块代码所在路径                        |
| 嵌套深度     | depth   | 程序生成    | no     | 记录子模块的嵌套深度                    |

> -   可见性：指对于外部系统来说是否可见

## 生命周期

本系统的生命周期包含两个主要阶段，分别是**加载阶段**和**运行阶段**。
前者主要是在系统初始阶段对模块进行加载，在运行阶段的时候，也可以对模块进行重新加载。
后者则主要是系统从开始到结束这一段时期。

### 1. 加载阶段

`ModuleManager` 统一对模块进行加载，
这是本架构中最重要的部分，
它省去大部分导入模块，设置配置信息和管理子模块的工作，
只需要通过配置文件和少量的代码就可以拉起整个庞大系统。

加载阶段分为自动加载和手动加载。
系统会在初始阶段自动地加载所有配置的模块信息，并验证模块是否正确。
手动加载则是允许管理员在后期手动对某些模块进行切换。

> 注意：由于加载阶段是预先的操作，因此切记不要在构造函数 `__init__` 编写过多需要处理运行的逻辑，
> 这些代码应该编写在运行阶段的**钩子函数**中。

#### a. 自动加载

##### 加载模块信息

管理器会读取`modules.json`文件，并将其解析成 `ModuleInfo`对象。
配置文件的格式如下所示，基本内容与上述的属性值相同，

```typescript
interface Config {
    name: ModuleInfo;
}

interface ModuleInfo {
    alias: string;
    path?: string;
    modules?: string[];
    // 默认加载的视线类型
    default?: string;
    kinds?: string[];
}
```

##### 验证模块依赖

在本项目中，模块之间的依赖关系是树状的，
也就是不允许出现环，且每个模块只能被一个父模块所依赖。验证阶段首先会验证依赖的模块是否存在，
然后再通过 BFS 算法验证是否出现循环依赖和交叉依赖，
最后验证模块的具体实现是否存在。

> TODO: 交叉验证仍未实现

除此之外，在本阶段还能计算出每个子模块的嵌套深度。

##### 动态加载子模块

动态导入解决如何导入模块的问题，
导入模块所使用的是以下 3 个参数。

-   `path`: 模块所在代码路径
-   `name`: 模块的名字
-   `kind`: 模块的实现类型

最终的引用路径为`path.name.kind`，
当 kind 为 basic 时，将没有`kind`这层路径，
为`null`时，不会加载子模块。
对于具体的对象名称，则是格式为`KindName`的方式进行命名。

### 2. 运行阶段

1. 未运行 `Stopped`
2. 启动中 `Starting`
    1. **启动子模块**: 逐一启动子模块
    2. **更新配置信息**: 从配置文件中重新读取配置文件
    3. **模块自检**: 通过调用自定义的检测逻辑，保证模块时可运行的
3. 运行中 `Started`
4. 停止中 `Stopping`
    1. **等待线程停止**(可选):等待所有线程运行完毕，以优雅停机
    2. **停止子模块**: 逐一停止已经运行的模块
5. 未运行 `Stopped`

#### a. 钩子函数

每个模块而言可能存在一些自定义的加载逻辑，
在本系统中我们通过钩子函数进行实现。
通过重写钩子函数，自定义的加载逻辑就可以在对应的启动的生命周期中运行。
目前提供的钩子函数如下。

-   `Starting` 前
-   `Started` 前（指完成所有启动逻辑之后）

> 注意；在生命周期中代码的执行过程中，会修改标志位，因此有些钩子函数会针对这个标志位的修改时机

#### b. 多线程

某些模块在启动之后，需要持续的运行处理，
因此需要使用多线程的技术。
本系统为了对多线程的创建和回收进行统一的管理，
因此封装了 `make_thread` 用于创建和运行线程。
该函数创建的线程对象会存储在模块内部，
开发者需要自行选择合适的钩子函数作为时机，创建和运行线程。

在线程内部，通常使用死循环的方式进行循环操作，以保证可持续运行。
但是在实际实现上，需要通过标志位来控制线程终止，
以进行优雅地停机。
目前本系统提供 `is_running` 属性，
当模块处于 `Started` 和 `Starting` 时，
该属性为 `true`。
