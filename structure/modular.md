# 模块化

虽然在之前的系统设计上，我们称系统中的每一个功能组件都是一个模块，
但实际上在具体的代码实现，每个模块的内部实现不同，导致其具体实现上有一定的差异，
使得我们需要为每个类都涉及一套代码实现，并且还需要手动地加载和连接各个模块。

因此，为了简化这部分的代码开发工作量，让系统本身自动化地完成模块加载和连接，
我们提出了模块化的思想。

> 注意：本系统在代码实现层面不再刻意区分 `interface` 和 `module`，
> 而是在具体的功能性质上有所差异。
> 比如 `interface` 主要负责对外交互，`module` 主要负责内部实现。

## 概念

<!-- 这里模块化思想其实与 Linux 系统中的文件系统如出一辙，
在 Linux 系统中，所有的硬件设备、文件内容和文件夹都属于文件，
共用一套统一的 IO 控制接口。 -->

<!-- 在我们这套系统中也是如此，任何一个具体模块都继承与一个统一的模块接口，
它们共用一套统一的启动、运行和管理接口。
此外，模块之间也能互相嵌套（不允许发生循环依赖），父模块会自动加载子模块。 -->

模块化的概念是指在本系统中的所有功能实现都属于模块，
都继承于 `BasicModule` 对象。
同时，模块具有嵌套性，
也就是说一个模块会包含多个子模块，
通过父子模块的关联系，其在系统内部形成一条紧密的依赖树，
在实际开发过程中，开发者就不需要手动创建各个模块。

除了大语言模型、文本转语音这些实际提供功能的传统模块之外，
将这些功能组合起来的对象也属于模块，
所以，实质上来说，
数字人系统其内核就是一个包含许多子模块的嵌套的大型模块。

在模块化的框架，其最重要的是 模块化管理器 (`ModuleManager`)。
其在初始阶段从模块配置文件中读取各个模块的信息，
此后在运行时刻动态地从代码文件中加载模块对象。
该管理器是单例模式的，也就是系统中只存在一个实例对象，
系统中的所有操作都是通过这个实例对象进行操作。

![img](./img/modular.svg)

## 属性

`ModuleInfo` 对象用于存储每个模块的基本属性，
`modules.json` 文件会持久化地存储这些属性信息。

| 名称         | 字段    | 默认值      | 可见性 | 备注                                    |
| ------------ | ------- | ----------- | ------ | --------------------------------------- |
| 名称         | name    | 必须        | yes    |                                         |
| 别名         | alias   | 必须        | yes    | 模块对应的中文名                        |
| 子模块列表   | modules | `[]`        | yes    | 存储包含的子模块                        |
| 实现类型     | kind    | `basic`     | yes    | `basic` 指只有一种实现, `null` 指为实现 |
| 实现类型列表 | kinds   | `[]`        | yes    | 存储目前已经支持的试下类型              |
| 状态         | status  | `NotLoaded` | yes    |                                         |
| 路径         | path    | `.`         | no     | 模块代码所在路径                        |
| 嵌套深度     | depth   | 程序生成    | no     | 记录子模块的嵌套深度                    |

> -   可见性：指对于外部系统来说是否可见

## 生命周期

本系统的生命周期包含两个主要阶段，分别是**加载阶段**和**运行阶段**。
前者主要是在系统初始阶段对模块进行加载，在运行阶段的时候，也可以对模块进行重新加载。
后者则主要是系统从开始到结束这一段时期。

### 1. 加载阶段

`ModuleManager` 统一对模块进行加载，
这是本架构中最重要的部分，
它省去大部分导入模块，设置配置信息和管理子模块的工作，
只需要通过配置文件和少量的代码就可以拉起整个庞大系统。

加载阶段分为自动加载和手动加载。
系统会在初始阶段自动地加载所有配置的模块信息，并验证模块是否正确。
手动加载则是允许管理员在后期手动对某些模块进行切换。

> **注意:** 由于加载阶段是预先的操作，因此切记不要在构造函数 `__init__` 编写过多需要处理运行的逻辑，
> 这些代码应该编写在运行阶段的**钩子函数**中。

#### a. 自动加载

自动加载阶段分为以下 3 个步骤。

> **注意:** 自动加载需要在程序启动时手动调用 `manager.load_modules()` 函数。
> 如果程序在类加载阶段进行自动加载，则会出现**循环依赖**的问题，
> 因此只能在运行时刻手动调用。

##### 加载模块信息

管理器会读取`modules.json`文件，并将其解析成 `ModuleInfo`对象。
配置文件的格式如下所示，基本内容与上述的属性值相同，

```typescript
interface Config {
    name: ModuleInfo;
}

interface ModuleInfo {
    alias: string;
    path?: string;
    modules?: string[];
    // 默认加载的实现类型，系统启动时会加载该实现类型
    default?: string;
    kinds?: string[];
}
```

##### 验证模块依赖

在本项目中，模块之间的依赖关系是树状的，
也就是不允许出现环，且每个模块只能被一个父模块所依赖。验证阶段首先会验证依赖的模块是否存在，
然后再通过 BFS 算法验证是否出现循环依赖和交叉依赖，
最后验证模块的具体实现是否存在。

> TODO: 交叉验证仍未实现...

除此之外，在本阶段还能计算出每个子模块的嵌套深度。

##### 动态加载子模块

动态导入解决如何导入模块的问题，
导入模块所使用的是以下 3 个参数。

-   `path`: 模块所在代码路径
-   `name`: 模块的名字
-   `kind`: 模块的实现类型

最终的引用路径为`path.name.kind`，
当 kind 为 basic 时，将没有`kind`这层路径，
为`null`时，不会加载子模块。
对于具体的对象名称，则是格式为`KindName`的方式进行命名。

### 2. 运行阶段

1. 未运行 `Stopped`
2. 启动中 `Starting`
    1. **启动子模块**: 逐一启动子模块
    2. **更新配置信息**: 从配置文件中重新读取配置文件
    3. **模块自检**: 通过调用自定义的检测逻辑，保证模块时可运行的
3. 运行中 `Started`
4. 停止中 `Stopping`
    1. **等待线程停止**(可选):等待所有线程运行完毕，以优雅停机
    2. **停止子模块**: 逐一停止已经运行的模块
5. 未运行 `Stopped`

#### a. 钩子函数

每个模块而言可能存在一些自定义的加载逻辑，
在本系统中我们通过钩子函数进行实现。
通过重写钩子函数，自定义的加载逻辑就可以在对应的启动的生命周期中运行。
目前提供的钩子函数如下。

-   `Starting` 前
-   `Started` 前（指完成所有启动逻辑之后）

> 注意；在生命周期中代码的执行过程中，会修改标志位，因此有些钩子函数会针对这个标志位的修改时机

#### b. 多线程

某些模块在启动之后，需要持续的运行处理，
因此需要使用多线程的技术。
本系统为了对多线程的创建和回收进行统一的管理，
因此封装了 `make_thread` 用于创建和运行线程。
该函数创建的线程对象会存储在模块内部，
开发者需要自行选择合适的钩子函数作为时机，创建和运行线程。

在线程内部，通常使用死循环的方式进行循环操作，以保证可持续运行。
但是在实际实现上，需要通过标志位来控制线程终止，
以进行优雅地停机。
目前本系统提供 `is_running` 属性，
当模块处于 `Started` 和 `Starting` 时，
该属性为 `true`。

## 使用说明

### 1. 单独测试模块

目前本系统提供两种进行单独测试的方法。

#### a. 使用 Cli 控制器

通过指令 `python src/cli/app.py` 即可启动控制器，
控制器目前支持的指令内容可以查看[相关文档](../controller/cli.md)。
由于本系统支持对可控模块进行单独控制（启动/停止），
且部分模块也支持虚拟 (`virtual`) 模块实现，
因此控制器尽管启动了整个系统，也可以方便地对特定模块进行测试。

#### b. 手动导入模块

如果不想使用该控制器进行调试，也可以通过手动导入模块，其具体步骤如下。

```python
# 1. 确认 src/modules.json 文件中是否配置了所需的模块实现类型
# 2. 导入模块管理器单例对象
from module.interface.manager import manager

name = "xxx"
kind = "xxx"

# 3. 加载模块
manager.load_modules()

# 4. (可选) 如果不想修改 src/modules.json 文件，
# 可以手动切换到所需的模块实现类型
# manger.change_module_kind(name, kind)

# 5. 导入对应模块
module = manager.object(name)

# 6. 启动模块
module.start()
```

> **注意:** 不能直接通过 `module = Module()` 的方式进行创建模块对象
