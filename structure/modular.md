# 模块化

虽然在之前的系统设计上，我们称系统中的每一个功能组件都是一个模块，
但实际上在具体的代码实现，每个模块的内部实现不同，导致其具体实现上有一定的差异，
使得我们需要为每个类都涉及一套代码实现，并且还需要手动地加载和连接各个模块。

因此，为了简化这部分的代码开发工作量，让系统本身自动化地完成模块加载和连接，
我们提出了模块化的思想。

> 注意：本系统在代码实现层面不再刻意区分 `interface` 和 `module`，
> 而是在具体的功能性质上有所差异。
> 比如 `interface` 主要负责对外交互，`module` 主要负责内部实现。

## 概念

<!-- 这里模块化思想其实与 Linux 系统中的文件系统如出一辙，
在 Linux 系统中，所有的硬件设备、文件内容和文件夹都属于文件，
共用一套统一的 IO 控制接口。 -->

<!-- 在我们这套系统中也是如此，任何一个具体模块都继承与一个统一的模块接口，
它们共用一套统一的启动、运行和管理接口。
此外，模块之间也能互相嵌套（不允许发生循环依赖），父模块会自动加载子模块。 -->

模块化的概念是指在本系统中的所有功能实现都属于模块，
都继承于 `BasicModule` 对象。
同时，模块具有嵌套性，
也就是说一个模块会包含多个子模块，
通过父子模块的关联系，其在系统内部形成一条紧密的依赖树，
在实际开发过程中，开发者就不需要手动创建各个模块。

除了大语言模型、文本转语音这些实际提供功能的传统模块之外，
将这些功能组合起来的对象也属于模块，
所以，实质上来说，
数字人系统其内核就是一个包含许多子模块的嵌套的大型模块。

在模块化的框架，其最重要的是 模块化管理器 (`ModuleManager`)。
管理器会自动从配置文件中加载模块信息 (`ModuleInfo`)，
然后将其封装成一些模块管理单元 (`ModuleManageCell`)，
此后在运行时动态地导入这些模块，并注入模块相关的依赖。

![img](./img/modular.svg)

### IoC 与 DI

在先前的模块化架构设计中，模块实现为了获取到全局的信息，
需要拥有模块管理器的单例实现，
这样也会导致出现一条额外的依赖关系，造成循环依赖。
此后，我们参考 Spring 框架的**控制反转**和**依赖注入**，
砍掉了这条多余的依赖。

-   **控制反转**：在此前，用户的对模块的启停操控是对模块本身进行控制。
    但在目前系统架构中，所有对模块的操作都是通过模块管理器，
    也就是说控制权发生了反转。
-   **依赖注入**：模块实现获取全局信息，不再是拥有模块管理器来获取，
    而是管理器在加载模块时，通过我 set 函数将模块需要的依赖（包括模块名称、实现类型和子模块等）
    注入给该模块。

## 属性

| 名称         | 字段     | 默认值   | 可见性 | 备注                                          |
| ------------ | -------- | -------- | ------ | --------------------------------------------- |
| 名称         | name     | 必须     | yes    |                                               |
| 别名         | alias    | 必须     | yes    | 模块对应的中文名                              |
| 实现类型     | kind     | `basic`  | yes    | `basic` 指默认（基础）实现, `null` 指为空实现 |
| 实现类型列表 | kinds    | `[]`     | yes    | 存储目前已经支持的实现类型                    |
| 非空性       | not_null | `true`   | no     | 记录该模块是否能被加载为空                    |
| 路径         | path     | ``       | no     | 模块代码所在路径, `module` 目录的相对路径     |
| 父模块       | sup      | 程序生成 | yes    | 父模块名                                      |
| 子模块列表   | sub      | `[]`     | yes    | 包含的子模块名                                |
| 嵌套深度     | depth    | 程序生成 | no     | 记录子模块的嵌套深度                          |

由于模块状态属于模块运行阶段的属性，不属于模块的持久化信息，因此保存在模块管理单元内。

> 可见性：指对于外部系统来说是否可见

### 实现类型

每个模块可以存在多个具体的实现类型，
但是本系统保留了 2 个实现类型名称 `basic` 和 `null`。

`basic` 是模块的第一种实现类型，
也就是说，如果模块只有一种实现，那么它的实现类型名称就是`basic`。
当然，如果存在多个实现类型时，该实现类型也是存在的，
不过其动态导入的路径会有所区别（在**动态导入**部分会详细说明）。

`null` 是指空实现，其在动态导入过程时会直接返回 `None`。
引入空实现的原因，主要是用于关闭一些非核心的模块。
`null`并不需要在实现类型列表中显式注明，
只需控制 `not_null` 属性即可。
当然，在进行父模块功能开发时也需要注意这些空模块的调用问题。

### 可控模块

本系统提供更细粒度控制模块逻辑，
我们称 `booter` 的一级子模块为**可控模块**（当然其本身也是）。
一方面为了更细粒度地控制不同模块的启停，
避免系统切换开销过大。
另一方面，则是并不是所有模块都需要控制，
而且单独启动也并没有意义（除了程序调试）。

当然，系统通过引入`null`实现类型，来补充对模块的控制能力。
当模块实现被设置为`null`时，系统在启动时就不会加载该模块，
自然不会启动该模块。
一个模块都否被设置为空实现由`not_null`属性决定。

> 目前仅在 Webui 控制器对其进行限制。

## 生命周期

本系统的生命周期包含两个主要阶段，分别是**加载阶段**和**运行阶段**。
前者主要是在系统初始阶段对模块进行加载，在运行阶段的时候，也可以对模块进行重新加载。
后者则主要是系统从开始到结束这一段时期。

### 1. 加载阶段

`ModuleManager` 统一对模块进行加载，
这是本架构中最重要的部分，
它省去大部分导入模块，设置配置信息和管理子模块的工作，
只需要通过配置文件和少量的代码就可以拉起整个庞大系统。

加载阶段分为自动加载和手动加载。
系统会在初始阶段自动地加载所有配置的模块信息，并验证模块是否正确。
手动加载则是允许管理员在后期手动对某些模块进行切换。

> **注意:** 由于加载阶段是由管理器自动运行，
> 管理器不会使用构造函数传递值进行初始化，因此请保证每个模块对象都存在无参构造，或者每个参数都存在默认是。
>
> 由于模块构造之后，并不代表真正运行，所以切记不要在构造函数 `__init__` 编写过多需要处理运行的逻辑，
> 这些逻辑应该通过重写在运行阶段的**钩子函数**实现 。

#### a. 自动加载

自动加载阶段分为以下 3 个步骤。

> **注意:** 自动加载需要在程序启动时手动调用 `manager.load_modules()` 函数。
> 如果程序在类加载阶段进行自动加载，则会出现**循环依赖**的问题，
> 因此只能在运行时刻手动调用。

##### 加载模块信息

管理器会读取`modules.json`文件，并将其解析成 `ModuleInfo`对象，
最后在为每个模块创建对应的管理单元。
配置文件的格式如下所示，基本内容与上述的属性值相同，

> **注意:** 在`ModuleInfo`属性名使用下划线命名法，而`modules.json`中使用小驼峰命名法。

```typescript
interface Config {
    name: ModuleInfo;
}

interface ModuleInfo {
    alias: string;
    // 默认加载的实现类型，系统启动时会加载该实现类型
    default?: string;
    kinds?: string[];
    modules?: string[];
    path?: string;
    notNull?: boolean;
}
```

`ModuleInfo` 中的属性可以根据可配置性可以分为以下 3 类。
无论是哪种类型，其都作为模块属性，并且可以被访问。

1. 必须项：属性必须配置
2. 可选项：如果属性没有配置，系统也会赋予默认值
3. 生成项：属性无需配置，系统会在根据其他属性进行计算生成得到

为了方便配置，本系统也存在以下配置语法糖。

-   当`kind`没有被配置或为`basic`，且`kinds`没有被配置或为空数组。系统会设置默认配置为`basic`，且被实现类型包含。
-   当配置`notNull`为`false`时，会自动向`kinds`中添加`null`

> **注意:** 目前并没有对`kinds`中的`null`进行冗余检查，所以设置 `not_null` 为 `false` 后，
> 请勿再在 `kinds` 中添加 `kind`

##### 验证模块依赖

验证模块分为两部分内容，分别是模块本身的验证，然后是其实现类型的验证。

本系统重模块之间的依赖关系是树状的，
也就是不允许出现环，且每个模块只能被一个父模块所依赖。验证阶段首先会验证依赖的模块是否存在，
然后再通过 BFS 算法验证是否出现循环依赖和交叉依赖，
最后验证模块的具体实现是否存在。
除此之外，在本阶段还能计算出每个子模块的嵌套深度。

> TODO: 交叉验证仍未实现...

验证模块实现类型时，首先会验证当前选择的实现类型是否包含在可支持的列表 (`kinds`) 中，
然后通过一下动态导入验证这些实例对象是否存在。
值得注意的是，此处仅是导入，并不会创建实例对象。

##### 动态导入

动态导入解决如何导入模块的问题，
导入模块所使用的是以下 3 个参数。

-   `path`: 模块所在代码路径
-   `name`: 模块的名字
-   `kind`: 模块的实现类型

配置文件的路径是`module`目录的相对路径，
管理器最终引用路径为`module.path.name.kind`，
当 kind 为 basic 时，将没有`kind`这层路径，
为`null`时，不会加载子模块。
每个模块类的名称使用大驼峰命名法，格式为`KindName`。

动态导入的的过程可以被转换一下代码运行逻辑，
`path`, `kind`, `name` 对应实际的配置信息。

```python
if kind == NULL:
    return None
else kind == BASIC:
    from module.path.name import BasicName
else:
    from module.path.name.kind import KindName
```

> **注意:** 大驼峰命名法意味着无论配置文件中 `kind` 为什么，
> 最终只会将开头字母大写。

### 2. 运行阶段

1. **未运行** `Stopped`
2. **启动中** `Starting`
    1. “启动子模块”前钩子函数
    2. 启动子模块: 逐一启动子模块
    3. 更新配置信息: 从配置文件中重新读取配置文件
    4. 自定义启动逻辑
    5. 模块自检: 通过调用自定义的检测逻辑，保证模块时可运行的
3. **运行中** `Started`
4. **停止中** `Stopping`
    1. 自定义停止逻辑
    2. 等待线程停止(可选): 等待所有线程运行完毕，以优雅停机
    3. 停止子模块: 逐一停止已经运行的模块
    4. “停止子模块”后钩子函数
5. **未运行** `Stopped`

值得注意的是，在启动时，父模块需要等子模块都启动完成后，
才会启动付模块的内部逻辑。
而在停止时，父模块则会首先停止模块的内部逻辑，
然后再停止子模块逻辑。
此处区别在开发时需要注意甄别。

#### a. 钩子函数

每个模块而言可能存在一些自定义的加载逻辑，
在本系统中我们通过钩子函数进行实现。
通过重写钩子函数，自定义的加载逻辑就可以在对应的启动的生命周期中运行。
目前提供的钩子函数如下。

-   “启动子模块”前: `before_starting_submodules`
-   自定义启动逻辑: `handing_starting`
-   自定义停止逻辑: `handing_stopping`
-   “停止子模块”后: `after_stopping_submodules`

#### b. 级联启动

本系统存在父子模块依赖的关系，因此在管理器启动模块时，
也会级联启动其父模块或子模块。
对于控制模块启动的函数中，
系统提供了两个参数，`with_sub` 与 `with_sup`。
前者会级联启动该模块的所有子模块，
后者则会级联启动该模块的父模块。
值得注意的是，级联启动具有方向性，
也就是当子模块启动父模块，只会继续启动父模块的父模块，
而不会启动父模块的子模块。当然，子模块同理。

管理员在控制模块时，既会级联启动其父模块，也会级联启动其子模块，
其顺序为 子模块 -> 本身 -> 父模块。

#### c. 多线程

某些模块在启动之后，需要持续的运行处理，
因此需要使用多线程的技术。
本系统为了对多线程的创建和回收进行统一的管理，
因此封装了 `make_thread` 用于创建和运行线程。
该函数创建的线程对象会存储在模块内部，
开发者需要自行选择合适的钩子函数作为时机，创建和运行线程。

在线程内部，通常使用死循环的方式进行循环操作，以保证可持续运行。
但是在实际实现上，需要通过标志位来控制线程终止，
以进行优雅地停机。
目前本系统提供 `is_running` 属性，
当模块处于 `Started` 和 `Starting` 时，
该属性为 `true`。
